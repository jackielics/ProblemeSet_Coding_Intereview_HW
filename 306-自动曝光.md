# 306-自动曝光

## 题目描述
一个图像有n个像素点，存储在一个长度为n的数组img里，每个像素点的取值范围[0,255]的正整数。
请你给图像每个像素点值加上一个整数k（可以是负数），得到新图newImg，使得新图newImg的所有像素平均值最接近中位值128。 \
请输出这个整数k。

## 输入描述
n个整数，中间用空格分开
例如：
`0 0 0 0`  
4个数值，中间用空格分开
## 输出描述
一个整数k  
备注：
- $1≤n≤100$
- 如有多个整数 k 都满足，输出小的那个 k；
- 新图的像素值会自动截取到[0,255] 范围。当新像素值<0，其值会更改为0；当新像素值>255，其值会更改为255；
例如newImg="-1 -2 256",会自动更改为"0 0 255"

### 示例一
**输入：**
```shell
0 0 0 0
```

**输出：**
```shell
128
```

**说明：**  
四个像素值都为0

### 示例二
**输入：**
```shell
129 130 129 130
```

**输出：**
```shell
-2
```

**说明：**  
-1的均值128.5，-2的均值为127.5，输出较小的数-2

## 解题思路
该题是一种图像亮度调整算法，主要思路是将输入的一维灰度图像的亮度调整到 128 级别，具体实现是通过计算原始图像的灰度平均值和 128 的差值，然后依次增减每个像素的值直到达到期望值，返回最少需要增减多少次。其中，更新新的图像灰度值的函数update_and_get_avg 负责增减每个像素的值并返回新图像的灰度平均值。

## 解题代码

```python
import sys
 
# 输入获取
arr = list(map(int, input().split()))
 
 
# 算法入口
def getResult(arr):
    minDiff = sys.maxsize
    ans = None
 
    for k in range(-127, 129):
        sum = 0
        for j in range(len(arr)):
            # 新图的像素值会自动截取到[0,255]范围。当新像素值<0，其值会更改为0；当新像素值>255，其值会更改为255；
            newVal = min(max(0, arr[j] + k), 255)
            sum += newVal
 
        diff = abs(sum / len(arr) - 128)
 
        if diff < minDiff:
            minDiff = diff
            ans = k
        elif diff == minDiff and ans is not None:
            # 如有多个整数k都满足，输出小的那个k
            ans = min(ans, k)
 
    return ans
 
 
# 算法调用
print(getResult(arr))
```