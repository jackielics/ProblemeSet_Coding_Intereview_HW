# 312 静态扫描最优成本

## 题目描述
静态扫描快速识别源代码的缺陷，静态扫描的结果以扫描报告作为输出：  
1. 文件扫描的成本和文件大小相关，如果文件大小为 
N ，则扫描成本为 N 个金币  
2. 扫描报告的缓存成本和文件大小无关，每缓存一个报告需要 M 个金币
3. 扫描报告缓存后，后继再碰到该文件则不需要扫描成本，直接获取缓存结果


给出源代码文件标识序列和文件大小序列，求解采用合理的缓存策略，最少需要的金币数。
## 输入描述
第一行为缓存一个报告金币数 $M,1≤M≤100$  
第二行为文件标识序列：$F_1,F_2,F_3...F_n$，其中 
$1≤N≤10000,1≤F_i≤1000$  
第二行为文件大小序列：$S_1,S_2,S_3...S_n$，其中 
$1≤N≤10000,1≤S_i≤10$ 

## 输出描述
采用合理的缓存策略，需要的最少金币数

### 示例一
**输入：**
```shell
5
1 2 2 1 2 3 4
1 1 1 1 1 1 1
```

**输出：**
```shell
7
```

**说明：**  
文件大小相同，扫描成本均为1个金币。缓存任意文件均不合算，因而最少成本为7金币

### 示例二
**输入：**
```shell
5
2 2 2 2 2 5 2 2 2
3 3 3 3 3 1 3 3 3
```

**输出：**
```shell
9
```

**说明：**  
2号文件出现了3次，扫描加缓存成本共计3+5=8，不缓存成本为3*8=24，显然缓存更优，最优成本为8+1=9。

## 解题思路
- 定义了一个名为 solve_method 的函数，该函数接收三个参数: m、ids_str 和 sizes_str。
- 创建两个字典 id_cost和 id_size，分别存储 id 对应的数量和大小。
- 使用 split 方法分别将字符串 ids_str 和 sizes_str 拆分为列表 ids 和 sizes。
- 遍历列表ids，并通过 int 函数将每一项转换为整数。对于每一项，将其对应的数量加 1，并存储该 id 的大小.
- 遍历字典 id_cost 中的每一个 id，累加每一个 id 对应的最小数量。

## 解题代码

```python
# 输入获取
m = int(input())
f = list(map(int, input().split()))
s = list(map(int, input().split()))
 
 
# 算法入口
def getResult(m, f, s):
    # count用于保存每个文件出现的次数
    count = {}
    # size用于保存文件的大小，即扫描成本
    size = {}
 
    for i in range(len(f)):
        # k是文件标识
        k = f[i]
        if count.get(k) is None:
            count[k] = 1
        else:
            count[k] += 1
 
        if size.get(k) is None:
            size[k] = s[i]
 
    ans = 0
    for k in count.keys():
        # 选择每次都重新扫描的成本  和  扫描一次+缓存的成本  中最小的
        ans += min(count[k] * size[k], size[k] + m)
    return ans
 
 
print(getResult(m, f, s))
```